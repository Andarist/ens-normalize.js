<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<title>Emoji</title>
<style>
body {
	margin: 1rem;
}
#arrows {
	width: 1.5rem;
	height: 1.5rem;
	animation: spin 2s infinite linear;
	user-select: none;
}
@keyframes spin {
	from { transform:rotate(0deg); }
	to	 { transform:rotate(360deg); }
}
#versions {
	position: absolute;
	right: 1rem;
	top: 1rem;
	text-align: right;
}
#loading {
	display: inline-flex;
	background: #ffc;
	border-radius: 1rem;
	padding: 1rem 2rem;
	font-size: 24pt;
	border: 1px solid #ccc;
	gap: 1rem;
	align-items: center;
	margin-top: 1rem;
}
section table {
	border-collapse: collapse;
	width: 100%;
}
.error-count {
	font-weight: bold;
	color: #f00;
}
td { 
	border: 1px solid #aaa; 
	text-align: center;
}
td + td.emoji {
	border-left-width: 5px;
}
thead {
	position: -webkit-sticky;
	position: sticky; 
	top: 0; 
	z-index: 1;
}
thead th {
	background: #fff;
	background-clip: padding-box;
}
tbody tr:nth-child(odd) {
	background: #eee; 
}
td.desc {
	text-align: left;
}
td.form {
	font-size: 16pt;
	text-align: center;
}
td.src {
	font-family: monospace;
}
td.verbatim {
	background: #ffc;
}
td.valid {
	background: #cfc;
}
td.error {
	background: #fcc;
}
td.disallowed {
	background: #f66;
}
td.different {
	background: #fc9;
}
td.emoji {
	background: #cff;
}
td.emoji.only {
	background: #66f;
}
.tokens {
	justify-content: center;
}
.legend {
	display: flex;
	align-items: center;
}
.legend table {
	display: inline-table;
	border-collapse: collapse;
}
.legend td {
	padding: 2px;
}
</style>
</head>
<body>
<h1>Emoji</h1>
<div id="versions"><a href="https://github.com/adraffy/ens-normalize.js">@adraffy/ens-normalize</a></div>
<div class="legend">
Pictograph and Single Character Emoji have no preferred appearance: 
<table><tr>
<td class="valid">Valid</td>
<td class="verbatim">Verbatim</td>
<td class="different">Different</td>
<td class="disallowed">Disallowed</td>
</tr></table></div>
<div class="legend">
Sequences have a known appearance: 
<table class="legend"><tr>
<td class="verbatim">Verbatim</td>
<td class="different">Different</td>
<td class="disallowed">Disallowed</td>
</tr></table>
</div>
<div id="loading">
<svg id="arrows" class="hide" viewBox="0 0 1000 1000" xmlns="http://www.w3.org/2000/svg">
<path d="M990,377.5H622.5l137.4-137.4C690.4,170.7,598.2,132.5,500,132.5c-98.2,0-190.4,38.2-259.9,107.6C170.7,309.6,132.5,401.8,132.5,500c0,98.2,38.2,190.4,107.6,259.9c69.4,69.4,161.7,107.6,259.9,107.6c98.2,0,190.4-38.2,259.9-107.6c5.8-5.8,11.4-11.8,16.7-17.9l92.2,80.7C778.9,925.2,647,990,500,990C229.4,990,10,770.6,10,500C10,229.4,229.4,10,500,10c135.3,0,257.8,54.9,346.5,143.5L990,10V377.5z"/>
</svg>
<span>Downloading...</span></div>	
<ul id="toc"></ul>
<script type="module">
import {escape_name_for_html, parse_cp_range, parse_cp_sequence, hex_cp, map_values, compare_arrays} from '../build/utils.js';
import {ens_normalize, ens_tokenize, BUILT, VERSION, UNICODE} from '../dist/ens-normalize-debug.min.js';
import {ens_normalize as normCompat, ens_tokenize as tokenizeCompat} from '../dist/ens-normalize-compat.min.js';
import {ens_normalize as norm2003, ens_tokenize as tokenize2003} from '../dist/ens-normalize-2003.js';
import {ens_normalize as norm2008, ens_tokenize as tokenize2008} from '../dist/ens-normalize-2008.min.js';
import {ens_normalize as normENS0, ens_tokenize as tokenizeENS0} from '../dist/ens-normalize-ENS0.min.js';
import {ens_normalize as normUTS51, ens_tokenize as tokenizeUTS51} from '../dist/ens-normalize-uts51.min.js';
import {dom_from_tokens, use_default_style} from '../dist/parts.min.js';

use_default_style();

const PRIMARY = 'adraffy';

const VERSIONS = [
	{idna: PRIMARY},
	{idna: 'Compat', normalize: normCompat, tokenize: tokenizeCompat},
	{idna: 'UTS51', normalize: normUTS51, tokenize: tokenizeUTS51},
	{idna: 'ENS0', normalize: normENS0, tokenize: tokenizeENS0},
	{idna: '2003', normalize: norm2003, tokenize: tokenize2003},
	{idna: '2008', normalize: norm2008, tokenize: tokenize2008},
];

document.querySelector('#versions').innerHTML += ` (v${VERSION}+U${UNICODE})<br>${VERSIONS.map(x => x.idna).join(', ')}<br><code>${BUILT}</code>`;

try {
	await main();
	// jump to anchor when finished
	window.location.hash = window.location.hash;
} catch (err) {
	let div = document.createElement('div');
	div.innerHTML = err.message;
	document.body.append(div);
	console.error(err);
}
document.querySelector('#loading').remove();

async function fetch_json(url) {
	let res = await fetch(url);
	if (res.status !== 200) throw new Error(`Download failed: HTTP Code ${res.status}`);
	return res.json();
}

async function update_state(state) {
	document.querySelector('#loading span').innerHTML = state;
	return new Promise(ful => {
		requestAnimationFrame(() => {
			requestAnimationFrame(ful);
		});
	});
}

function add_index_link(name, suffix) {
	document.querySelector('#toc').innerHTML += `<li><a href="#${name}">${name}</a>${suffix}</li>`;
}

async function main() {
	let [data, seqs, zwjs, custom_seqs, emojipedia] = await Promise.all([
		'../build/unicode-json/emoji-data.json',
		'../build/unicode-json/emoji-sequences.json',
		'../build/unicode-json/emoji-zwj-sequences.json',
		'./data/custom-sequences.json',
		'./data/emojipedia-missing-zwj-20211231.json'
	].map(fetch_json));

	await update_state('Computing');

	let {Emoji: emoji, Extended_Pictographic: picto} = data;

	emoji = new Set(emoji.flatMap(parse_cp_range));
	
	// find all of the non-emoji
	picto = picto.flatMap(parse_cp_range).filter(cp => !emoji.has(cp));

	// pluck out all of the single-char emoji
	let basic = new Set();
	seqs = map_values(seqs, srcs => srcs.flatMap(({src, desc}) => {
		if (src.includes('..')) {
			for (let cp of parse_cp_range(src)) {
				basic.add(cp);
				emoji.delete(cp);
			}
			return [];
		} else {
			let cps = parse_cp_sequence(src);
			if (cps.length == 1 || (cps.length == 2 && cps[1] == 0xFE0F)) {
				emoji.delete(cps[0]); 
			}
			return {cps, desc};
		}
	}));

	zwjs = zwjs.map(({src, desc}) => ({cps: parse_cp_sequence(src), desc}));
	let custom_chrs = [];
	custom_seqs = custom_seqs.map(({src, desc, error}) => ({cps: parse_cp_sequence(src), desc, error}));
	emojipedia = emojipedia.map(({src, desc}) => ({cps: parse_cp_sequence(src), desc}));

	basic = [...basic].sort((a, b) => a - b);
	emoji = [...emoji].sort((a, b) => a - b);

	// debug
	//await add_sequences('Test', [{cps:parse_cp_sequence('270A')}]);
	//await add_characters('Test', parse_cp_sequence('270A'), true);

	// these are nonstandard
	await add_sequences('Custom Sequences', custom_seqs, true);
	await add_sequences('Custom Characters', custom_chrs, true);
	await add_sequences('Missing ZWJ from Emojipedia', emojipedia)

	// these are standard
	await add_characters('Single Character Emoji', basic);
	await add_characters('Unknown Emoji', emoji);
	for (let [name, v] of Object.entries(seqs)) {
		await add_sequences(name, v);
	}
	await add_sequences('ZWJ Sequences', zwjs);
	await add_characters('Non-Emoji Pictographs', picto);
}

function str_from_tokens(tokens) {
	return String.fromCodePoint(...tokens.flatMap(({v,m,e}) => v ?? m ?? e ?? []));
}

async function add_sequences(name, seqs, show_errors = false) {
	if (seqs.length == 0) return;
	await update_state(`${name} (${seqs.length})`);

	let types = ['error', 'disallowed', 'different', 'verbatim'];
	
	let rows = seqs.map(({cps, desc, error}) => {
		let emoji = String.fromCodePoint(...cps);

		let type;
		let td0 = document.createElement('td');
		let norm0;
		try {
		 	norm0 = ens_normalize(emoji);
			let tokens = ens_tokenize(emoji);
			if (norm0 === emoji) {
				type = 'verbatim';
			} else {
				type = 'different';
				td0.append(dom_from_tokens(tokens));
			}
		} catch (err) {
			if (error) {
				type = 'valid';
			} else {
				type = 'error';
			}
			td0.innerHTML = err.message;
		}
		td0.classList.add(type);

		let tr = document.createElement('tr');
		tr.innerHTML = `<td class="desc">${desc}</td><td class="src">${cps.map(hex_cp).join(' ')}</td><td class="form">${emoji}</td>`;

		tr.append(...VERSIONS.map(({idna, tokenize, normalize}) => {
			if (idna == PRIMARY) return td0;
			let td = document.createElement('td');
			try {
				let norm = normalize(emoji);
				if (norm === emoji) { 
					td.classList.add('verbatim');
				} else if (norm === norm0) { // same as primary
					td.classList.add(type);
				} else {
					td.classList.add('different');
					td.append(dom_from_tokens(tokenize(emoji)));
				}
			} catch (err) {
				if (error) {
					td.classList.add('valid');
				} else {
					td.classList.add('disallowed');
				}
			}
			return td;
		}));

		return {type, tr};
	});

	// sort by type
	rows.sort((a, b) => types.indexOf(a.type) - types.indexOf(b.type));

	let errors = rows.filter(x => x.type == 'error').length;
	let suffix = ` (${seqs.length})`;
	if (errors > 0) {
		suffix += ` &rarr; <span class="error-count">${errors} errors</span>`;
	}

	// create html
	let section = document.createElement('section');
	section.innerHTML = `<h2><a name="${name}" href="#${name}">${name}</a>${suffix}</h2><table><thead><tr>
	<th>Description</th><th>Sequence</th><th>Form</th>${VERSIONS.map(x => `<th>${x.idna}</th>`).join('')}
	</tr></thead><tbody></tbody></table>`;
	section.querySelector('tbody').append(...rows.map(x => x.tr));
	document.body.append(section);	

	add_index_link(name, suffix);
}


async function add_characters(name, chars, show_errors = false, width = 3) {
	await update_state(`${name} (${chars.length})`);

	//<th>Dec</th>
	let cols = `<th>Hex</th><th>Form</th>${VERSIONS.map(x => `<th>${x.idna}</th>`).join('')}`;
	let rows = [];
	let buf = [];
	function drain() {
		let tr = document.createElement('tr');
		tr.append(...buf.flatMap(tr => [...tr.children]));
		rows.push(tr);
		buf.length = 0;
	}
	for (let cp of chars) {		
		let solo = String.fromCodePoint(cp);
		let styled = String.fromCodePoint(cp, 0xFE0F);
		let hex = hex_cp(cp);
		let tr = document.createElement('tr');
		//<td class="dec">${cp}</td>
		tr.innerHTML = `<td><a href="https://www.compart.com/en/unicode/U+${hex}">${hex}</td><td class="form">${escape_name_for_html(styled)}</td>`;

		let td0 = document.createElement('td');
		let norm0;
		let type;
		try {
			norm0 = ens_normalize(styled);
			if (norm0 === solo) {
				type = 'valid';
			} else {
				if (norm0 === styled) {
					type = 'verbatim';
				} else {
					type = 'different';
					td0.append(dom_from_tokens(ens_tokenize(solo)));
				}
			}
		} catch (err) {
			type = 'disallowed';
			if (show_errors) {
				td0.innerHTML = err.message;
			}
		}
		td0.classList.add(type);

		tr.append(...VERSIONS.map(({idna, tokenize, normalize}) => {
			if (idna == PRIMARY) return td0;	
			let td = document.createElement('td');
			try {
				let norm = normalize(styled);
				if (norm == norm0) { // same as primary
					td.classList.add(type);
				} else if (norm === solo) {
					td.classList.add('valid');
				} else {
					if (norm === styled) {
						td.classList.add('verbatim');
					} else {
						td.classList.add('different');
						td.append(dom_from_tokens(tokenize(solo)));
					}
				}
			} catch (err) {
				td.classList.add('disallowed');
				if (show_errors) {
					td.innerHTML = err.message;
				}
			}
			return td;
		}));
		buf.push(tr);
		if (buf.length == width) {
			drain();
		}		
	}
	if (buf.length > 0) drain();
	width = Math.min(width, rows.length);
	
	let suffix = ` (${chars.length})`;

	// add section
	let section = document.createElement('section');
	section.innerHTML = `<h2><a name="${name}" href="#${name}">${name}</a>${suffix}</h2><table><thead><tr>${Array(width).fill(cols).join('')}</tr></thead><tbody></tbody></table>`;
	section.querySelector('tbody').append(...rows);
	document.body.append(section);

	add_index_link(name, suffix);
}
</script>
</body>
</html>