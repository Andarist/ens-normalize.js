<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Confused Matrix</title>
<style>
.hide {
	display: none !important;
}
button, .control {
	cursor: pointer;
}
label {
	user-select: none;
}
body { 
	margin: 3rem; 
	background: #eee;
}
h1 {
	margin: 0;
}
#version {
	float: right;
	text-align: right;
}
table {
	border-collapse: collapse;
	border: 2px solid #888;
	background: #fff;
}
tr {
	height: 100%;
}
td, th {
	border: 1px solid #ccc;
}
th {
	background: #ddd;
	vertical-align: bottom;
	font: 12px monospace;
}
th.active {
	background: #f88;
}
th.valid {
	background: #0c0;
}
th.matched {
	border: 2px solid #000;
	background: #0f0;
}
th img {
	width: 1rem;
}

tr.valid {
	background: #eef;
}
tr.active {
	background: #ffc;
}
tr.first {
	border-top: 2px solid #888;
}
tr.free {
	background: #dff;
}
.hex {
	text-align: center;
	font: 12px monospace;
}
.form {
	text-align: center;
	font-size: 20px;
}
.form .tokens > * {
	flex: 1;
	justify-content: center;
}

.name {
	font-size: 12px;
}
.script {
	text-align: center;
	font-size: 12px;
	border-right: 2px solid #888;
}
.cell {
	padding: 2px;
	text-align: center;
}
.boxed {
	background: #ccc;
}
.primary {
	background: #afa;
}
.allow {
	background: #ccf;
}	
.unknown {
	background: #fc0;
}
.invalid {
	background: #fcc;
}
.norm-valid {
	font-weight: bold;
}
main > * {
	margin-top: 1rem;
}
#input_field {
	display: block;
	padding: 0.5rem;
	font-size: 16pt;
	width: 100%;
	box-sizing: border-box;
}
#exploded {
	font-size: 14pt;
	display: flex;
	gap: 4px;
}
#exploded .error {
	color: #555;
	background: #ffc;
	padding: 0.3rem;
	font-size: 12pt;
	border-radius: 0.5rem;
	border: 1px solid #ccc;
}
#output.error {
	background: #fcc;
	padding: 1rem;
	outline: 3px dashed #d00;
}
footer {
	text-align: center;
	color: #666;
	margin-top: 1rem;
	margin-bottom: 0.5rem;
}
</style>
</head>
<body>
<header>
<span id="version">
<a href="https://github.com/adraffy/ens-normalize.js">@adraffy/ens-normalize.js</a><br>
<a href="https://github.com/adraffy/ensip-norm">@adraffy/ensip-norm</a>
</span>
<h1>Confused Matrix</h1>
</header>
<main>
<div id="options">
<label class="control"><input id="norm_check" type="checkbox" checked>Enforce Normalization</label>
</div>
<div id="input">
<input id="input_field">	
</div>
<div id="exploded"></div>
<div id="output">Downloading data files...</div>	
</main>
<footer>Created by <a href="https://twitter.com/adraffy">raffy.eth</a></footer>
<script type="module">
import {
	ens_split, ens_tokenize,
	explode_cp, hex_cp, safe_str_from_cps, 
	dom_from_tokens, use_default_style
} from '../dist/all.min.js';
use_default_style();

const input_field = document.querySelector('#input_field');
const output_div = document.querySelector('#output');
const exploded_div = document.querySelector('#exploded');
const norm_check = document.querySelector('#norm_check');

let wholes;
let groups;
let scripts;
let char_map;
let whole_map;
let init = (async () => {

	let chars, ranges;
	[{wholes}, {chars, ranges, scripts}, {groups}] = await Promise.all([
		'../derive/output/confused.json',
		'../derive/output/names.json',
		'../derive/output/spec.json',
	].map(fetch_json));

	char_map = new Map(chars.map(([cp, name]) => [cp, {name}]));
	for (let [cp0, cp1, prefix] of ranges) {
		for (let cp = cp0; cp <= cp1; cp++) {
			let name = `${prefix} [${1+cp-cp0}/${1+cp1-cp0}]`;
			char_map.set(cp, {name});
		}
	}
	for (let s of scripts) {
		for (let cp of s.cps) {
			char_map.get(cp).script = s;
		}
	}

	let headerer = make_rotated_headerer(groups.map(g => g.name));
	form_header = headerer('Form');
	cp_header = headerer('Codepoint');
	ascii_header = headerer('ASCII');
	groups.forEach((g, i) => {
		g.index = i;
		g.header = headerer(g.name, g.restricted ? '#666' : '#000');
		g.valid_set = new Set([...g.primary, ...g.secondary]);
	});

	for (let w of wholes) {
		w.norm_set = new Set([...w.valid, ...w.confused]);

		w.defs.sort((a, b) => Math.min(...a.groups) - Math.min(...b.groups));
		w.defs.forEach(def => def.groups = def.groups.map(i => groups[i]));

		w.groups = [...new Set(w.defs.flatMap(def => def.groups))].sort((a, b) => a.index - b.index);

		w.decided = w.defs.some(def => def.type);

		let recs = [];
		for (let def of w.defs) {
			if (!w.norm_set.has(def.cp)) continue;
			//def.confused = w.confused.includes(def.cp);
			let gs = groups.filter(g => g.valid_set.has(def.cp));
			let rec = recs.find(({set}) => gs.some(g => set.has(g)));
			if (!rec) {
				rec = {w, set: new Set(), defs: [], tag: make_tag(recs.length)};
				recs.push(rec);
			}
			gs.forEach(g => rec.set.add(g));
			def.rec = rec;
			rec.defs.push(def);
		}
		w.recs = recs;

		let union = [...new Set(recs.flatMap(rec => [...rec.set]))];
		for (let rec of recs) {
			rec.complement = new Set(union.filter(g => !rec.set.has(g)));
		}
		w.rec_map = new Map(recs.flatMap(rec => rec.defs.map(def => [def.cp, rec]))); 

	}
	whole_map = new Map(wholes.flatMap(w => w.defs.map(def => [def.cp, w])));
	init = undefined;
})();

let form_header, cp_header, ascii_header;
input_field.addEventListener('input', update);
norm_check.addEventListener('input', update);
window.addEventListener('hashchange', check_hash);
check_hash();

async function check_hash(e) {
	input_field.value = decodeURIComponent(window.location.hash.slice(1));
	return update();
}

async function update() {
	output_div.innerHTML = '';
	output_div.classList.remove('error');
	let name = replace_escapes(input_field.value);
	window.history.replaceState(null, null, name ? `#${name}` : ' ');
	try {
		if (init) await init;
		await create_grid(name);
	} catch (err) {
		output_div.classList.add('error');
		output_div.innerHTML = `⚠️ ${err.message}`;
		console.log(err);
	}
}

async function create_grid(input) {
	
	let cps, match;
	let matched_type;

	if (match = input.match(/^group:(.*)$/i)) {
		let query = match[1].trim();
		let group = groups.find(g => strcmp(g.name, query) == 0);
		if (!group) throw new Error(`Unknown group: ${query}`);
		cps = group.primary;
	} else if (match = input.match(/^script:(.*)$/i)) {
		let query = match[1].trim();
		let script = scripts.find(s => strcmp(s.name, query) == 0 || strcmp(s.abbr, query) == 0);
		if (!script) throw new Error(`Unknown script: ${query}`);
		cps = script.cps;
	} else if (match = input.match(/^range:([0-9a-f]+)\.\.([0-9a-f]+)$/i)) {
		let lo = parseInt(match[1], 16);
		let hi = parseInt(match[2], 16);
		cps = [];
		while (lo <= hi) cps.push(lo++);
	} else if (!norm_check.checked) {
		cps = explode_cp(input);
	}

	exploded_div.classList.toggle('hide', !!cps);
	if (!cps) {
		let tokens = ens_tokenize(input, {nf: false});
		exploded_div.innerHTML = '';
		exploded_div.append(dom_from_tokens(tokens, {
			emoji_url: './emoji.html#q=%s',
		}));

		let split = ens_split(input);
		if (split.length != 1) throw new Error('multiple labels');
		split = split[0];
		if (split.error) {
			let error = document.createElement('div');
			error.classList.add('error');
			error.innerText = `⚠️ ${split.error.message}`;
			exploded_div.append(error);
		}
		matched_type = split.type;

		cps = split.tokens ? split.tokens.filter(x => !x.is_emoji).flat() : split.input;
	}

	if (!cps.length) return;

	let ws = new Set();
	let order = [...new Set(cps.map(cp => {
		let w = whole_map.get(cp);
		if (w) {
			ws.add(w);
			return w;
		} else {
			return cp;
		}
	}))];
	ws = [...ws];

	let cur_valid = new Set(groups.filter(g => cps.every(cp => g.valid_set.has(cp))));

	let group_universe = [...new Set(ws.flatMap(w => w.groups))].sort((a, b) => a.index - b.index);
	let table = document.createElement('table');
	
	let maker = group_universe;
	let shared = [];
	for (let cp of cps) {
		let whole = whole_map.get(cp);
		if (whole) {		
			if (whole.confused.includes(cp)) {
				let rec = whole.rec_map.get(cp);
				let set = rec.complement;
				maker = maker.filter(g => set.has(g));
				continue;
			}
		}
		shared.push(cp); 
	}
	maker = maker.filter(g => shared.every(cp => g.valid_set.has(cp)));

	maker = new Set(maker);

	let is_ascii = matched_type === 'ASCII';

	let added = Infinity;
	for (let ch of order) {
		if (Number.isInteger(ch)) {
			add_rows(1);
			let tr = document.createElement('tr');
			tr.classList.add('first', 'free');
			if ([...cur_valid].some(g => g.valid_set.has(ch))) {
				tr.classList.add('valid');
			}
			add_td_for_cp(tr, ch);
			for (let g of group_universe) {
				let td = document.createElement('td');
				if (g.valid_set.has(ch)) {
					td.classList.add('cell', 'primary', 'norm-valid');
					td.innerText = make_tag(0);
				}
				tr.append(td);
			}
			table.append(tr);
		} else {
			let {defs, valid, confused, decided, norm_set} = ch;
			add_rows(defs.length);
			let first = true;

			for (let def of defs) {
				let tr = document.createElement('tr');
				if (first) {
					tr.classList.add('first');
					first = false;
				}
				if (cps.includes(def.cp)) {
					tr.classList.add('active');
				}
				if ([...cur_valid].some(g => g.valid_set.has(def.cp))) {
					tr.classList.add('valid');
				}
				add_td_for_cp(tr, def.cp);

				let type = def.type;
				if (!type) {
					type = decided ? 'invalid' : 'unknown';
				}

				for (let g of group_universe) {
					let td = document.createElement('td');
					td.classList.add('cell');
					if (def.groups.includes(g)) {
						td.classList.add(type);
					}
					if (def.rec && def.rec.set.has(g)) {
						td.innerText = def.rec.tag;
						td.classList.add('boxed');
						if (valid.includes(def.cp)) {
							td.classList.add('norm-valid');
						} else if (confused.includes(def.cp)) {
							td.classList.add('norm-allow');
						}
					}
					tr.append(td);
				}
				table.append(tr);
			}
		}
	}
	output_div.append(table);

	function add_rows(n) {		
		added += n;
		if (added > 20) {
			added = n;
			table.append(header());
		}
	}

	function header() {
		let tr = document.createElement('tr');
		tr.classList.add('first');
		tr.append(
			create_th(form_header),
			create_th(cp_header),
			create_th('Name'),
			create_th('Script'),
		);
		tr.append(...group_universe.map(g => {
			let {name, header} = g;
			if (matched_type === 'ASCII' && name === 'Latin') {
				name = matched_type;
				header = ascii_header;
			}
			let th = create_th(header, `#group:${g.name}`);
			if (cur_valid.has(g)) {
				th.classList.add('valid');
			}
			if (maker.has(g)) {
				th.classList.add('active');
			}
			if (matched_type == name) {
				th.classList.add('matched');
			}
			return th;
		}));
		return tr;
	}

}

function create_th(s, url) {
	let th = document.createElement('th');
	let holder = th;
	if (url) {
		let a = document.createElement('a');
		a.href = url;
		holder = a;
		th.append(a);
	}
	if (s.startsWith('data:')) {
		let img = new Image();
		img.src = s;
		holder.append(img);
	} else {
		holder.innerHTML = s;
	}
	return th;
}


function make_tag(i) {
	if (i < 26) {
		return String.fromCharCode(0x41 + i);
	} else {
		return String.fromCharCode(0x40 + (i / 26|0), 0x41 + (i % 26));
	}
}

function add_td_for_cp(tr, cp) {

	let td_info = document.createElement('td');
	td_info.classList.add('form');
	td_info.innerText = safe_str_from_cps([cp]);
	//td_info.append(dom_from_tokens(ens_tokenize(String.fromCodePoint(cp)), {before: true}));
	tr.append(td_info);

	let td_hex = document.createElement('td');
	td_hex.classList.add('hex');
	td_hex.innerText = hex_cp(cp);
	tr.append(td_hex);

	let char = char_map.get(cp);

	let td_name = document.createElement('td');
	td_name.classList.add('name');
	td_name.innerText = char.name;
	tr.append(td_name);

	let td_script = document.createElement('td');
	td_script.classList.add('script');
	td_script.innerHTML = `<a href="#script:${char.script.abbr}">${char.script.name}</a>`;
	tr.append(td_script);
}

async function fetch_json(url) {
	let res = await fetch(url);
	if (res.status !== 200) throw new Error(`HTTP Error ${res.status}`);
	return res.json();
}

function strcmp(a, b) {
	return a.localeCompare(b, 'en', {sensitivity: 'base'});
}

function replace_escapes(s) {
	return s.replace(/(?:(?:\{([0-9a-f]+)\})|(?:\[((?:0x[0-9a-f]+)|[0-9]+)\]))/uig, (_, a, b, c) => {
		try {
			return String.fromCodePoint(a ? parseInt(a, 16) : parseInt(b)); 
		} catch (err) {
			return '�';
		}
	});
}

function make_rotated_headerer(names, font = '36px monospace') {
	let canvas0 = document.createElement('canvas');
	let ctx0 = canvas0.getContext('2d');
	ctx0.font = font;
	let metrics = names.map(name => ctx0.measureText(name));
	let width = metrics.reduce((a, x) => Math.max(a, x.actualBoundingBoxRight - x.actualBoundingBoxLeft), 0);
	let height = 2 * metrics.reduce((a, x) => Math.max(a, Math.max(x.actualBoundingBoxAscent, -x.actualBoundingBoxDescent)), 0);
	return (name, color = '#000') => {
		let canvas = document.createElement('canvas');
		canvas.width = height;
		canvas.height = width;
		let ctx = canvas.getContext('2d');
		ctx.font = font;
		ctx.fillStyle = color;
		ctx.textAlign = 'left';
		ctx.textBaseline = 'middle';
		let xc = height/2;
		let yc = width/2;
		ctx.translate(xc, yc);
		ctx.rotate(-Math.PI / 2);
		ctx.translate(-yc, -xc);
		ctx.fillText(name, 0, xc);
		return canvas.toDataURL();
	};
}

</script>
</body>
</html>